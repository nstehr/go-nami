package gonami

import (
	"crypto/md5"
	"crypto/rand"
	"fmt"
	"log"
	"net"
	"os"
	"path/filepath"
)

func onVersionState(pkt *Packet, e Encoder, conn net.Conn, t transfer) stateFn {
	log.Println("Comparing revisions")
	t.updateProgress(Progress{Type: HANDSHAKING, Message: "Comparing versions", Percentage: 0.25})
	if pkt.Type != REV {
		log.Println("Expecting REV, did not receive it")
		return nil
	}
	r, ok := pkt.Payload.(int)
	if !ok {
		log.Println("Incorrect payload type")
		return nil
	}

	if r != revision {
		log.Println("protocol revisions do not match")
		t.updateProgress(Progress{Type: ERROR, Message: "Versions do not match", Percentage: 0})
		return nil
	}
	return onBeginAuthState(pkt, e, conn, t)
}

func onBeginAuthState(pkt *Packet, e Encoder, conn net.Conn, t transfer) stateFn {
	log.Println("Generating auth token")
	//on connection, generate random bytes and send to the client
	random := generateRandomBytes()
	outPkt := &Packet{Type: AUTH, Payload: random}
	_, err := sendPacket(outPkt, conn, e)
	if err != nil {
		log.Println("Error sending AUTH token: " + err.Error())
		return nil
	}
	//use a closure to capture the value of the randomly generated bytes
	authenticateStateWrapper := func(pkt1 *Packet, e1 Encoder, conn1 net.Conn, t1 transfer) stateFn {
		return authenticateClientState(pkt1, e1, conn1, t1, random)
	}
	return authenticateStateWrapper
}

func authenticateClientState(pkt *Packet, e Encoder, conn net.Conn, t transfer, randomBytes []byte) stateFn {
	log.Println("Authenticating client")
	if pkt.Type != AUTH {
		log.Println("Expecting AUTH, did not receive it")
		return nil
	}
	//get the bytes the client sent over
	b, ok := pkt.Payload.([]byte)
	if !ok {
		log.Println("Incorrect payload type")
		return nil
	}
	//XOR our generated bytes with the secret
	xORd := xORSecret(randomBytes, secret)
	//and then MD5 hash to compare with client bytes
	hasher := md5.New()
	hashed := hasher.Sum(xORd)
	if len(hashed) != len(b) {
		log.Println("Authentication failed")
		t.updateProgress(Progress{Type: ERROR, Message: "Authentication failed", Percentage: 0})
		return nil
	}
	//compare the client bytes to our bytes to
	//see if the client is authenticated
	for i := 0; i < len(hashed); i++ {
		if hashed[i] != b[i] {
			log.Println("Authentication failed")
			t.updateProgress(Progress{Type: ERROR, Message: "Authentication failed", Percentage: 0})
			return nil
		}
	}
	t.updateProgress(Progress{Type: HANDSHAKING, Message: "Authentication Successful", Percentage: 0.50})
	outPkt := &Packet{Type: AUTH, Payload: []byte{000}}
	_, err := sendPacket(outPkt, conn, e)
	if err != nil {
		log.Println("Error sending AUTH token: " + err.Error())
		return nil
	}
	return validateFilenameState
}

func validateFilenameState(pkt *Packet, e Encoder, conn net.Conn, t transfer) stateFn {
	if pkt.Type != GET_FILE {
		log.Println("Expecting GET_FILE, did not receive it")
		return nil
	}
	filename, ok := pkt.Payload.(string)
	if !ok {
		log.Println("Incorrect payload type")
		return nil
	}
	payload := []byte{000}
	fullPath := filepath.Join(t.localDirectory(), filename)
	if _, err := os.Stat(fullPath); os.IsNotExist(err) {
		msg := "no such file or directory: " + fullPath
		log.Println(msg)
		t.updateProgress(Progress{Type: ERROR, Message: msg, Percentage: 0})
		payload = []byte{001}
	}
	outPkt := &Packet{Type: GET_FILE, Payload: payload}
	_, err := sendPacket(outPkt, conn, e)
	if err != nil {
		log.Println("Error sending GET_FILE: " + err.Error())
		return nil
	}
	//set the filename into the serverTransfer
	t.(*serverTransfer).fn = filename
	t.updateProgress(Progress{Type: HANDSHAKING, Message: "File found", Percentage: 0.75})
	return receiveConfigState
}

func receiveConfigState(pkt *Packet, e Encoder, conn net.Conn, t transfer) stateFn {
	if pkt.Type != GET_FILE {
		log.Println("Expecting GET_FILE, did not receive it")
		return nil
	}
	config, ok := pkt.Payload.(Config)
	if !ok {
		log.Println("Incorrect payload type")
		return nil
	}
	//send the filesize
	fullPath := t.fullPath()
	info, err := os.Stat(fullPath)
	if err != nil {
		log.Println("Error reading file: " + err.Error())
		return nil
	}
	filesize := info.Size()
	outPkt := &Packet{Type: GET_FILE, Payload: filesize}
	_, err = sendPacket(outPkt, conn, e)
	if err != nil {
		log.Println("Error sending GET_FILE: " + err.Error())
		return nil
	}
	//save the config
	t.(*serverTransfer).c = config
	t.updateProgress(Progress{Type: HANDSHAKING, Message: "Configuration received. Handshaking complete", Percentage: 1})

	return acceptListeningPortState
}

func acceptListeningPortState(pkt *Packet, e Encoder, conn net.Conn, t transfer) stateFn {
	port := pkt.Payload.(int)
	ip := conn.RemoteAddr().(*net.TCPAddr).IP.String()
	client := fmt.Sprintf("%s:%d", ip, port)
	t.(*serverTransfer).controlCh = make(chan controlMsg)
	go sendFile(client, e, t.(*serverTransfer))
	t.updateProgress(Progress{Type: TRANSFERRING, Message: "Starting transfer", Percentage: 0})
	return transferingState
}

func transferingState(pkt *Packet, e Encoder, conn net.Conn, t transfer) stateFn {

	switch pkt.Type {
	case RETRANSMIT:
		rt, ok := pkt.Payload.(Retransmit)
		if !ok {
			log.Println("Incorrect payload type")
			return nil
		}
		t.(*serverTransfer).controlCh <- controlMsg{msgType: RETRANSMIT, payload: rt}
		return transferingState
	case ERROR_RATE:
		errorRate, ok := pkt.Payload.(float64)
		if !ok {
			log.Println("Incorrect payload type")
			return nil
		}
		t.(*serverTransfer).controlCh <- controlMsg{msgType: ERROR_RATE, payload: errorRate}
	case DONE:
		t.(*serverTransfer).controlCh <- controlMsg{msgType: DONE}
		data, _ := e.Encode(pkt)
		conn.Write(data)
		t.updateProgress(Progress{Type: TRANSFERRING, Message: "Transfer Complete", Percentage: 1})
		return nil
	}
	return transferingState
}

func generateRandomBytes() []byte {
	size := 64
	rb := make([]byte, size)
	_, err := rand.Read(rb)
	if err != nil {
		log.Println(err)
	}

	return rb
}
