package server

import (
	"crypto/md5"
	"crypto/rand"
	"log"
	"net"

	"github.com/nstehr/go-nami/encoder"
	"github.com/nstehr/go-nami/message"
	"github.com/nstehr/go-nami/shared"
	"github.com/nstehr/go-nami/shared/transfer"
	"github.com/nstehr/go-nami/statemachine"
)

func onVersionState(pkt *message.Packet, e encoder.Encoder, conn net.Conn, progressCh chan transfer.Progress) statemachine.StateFn {
	log.Println("Comparing revisions")
	if pkt.Type != message.REV {
		log.Println("Expecting REV, did not receive it")
		return nil
	}
	revision, ok := pkt.Payload.(int)
	if !ok {
		log.Println("Incorrect payload type")
		return nil
	}

	if revision != shared.Revision {
		log.Println("protocol revisions do not match")
		return nil
	}
	return onBeginAuthState(pkt, e, conn, progressCh)
}

func onBeginAuthState(pkt *message.Packet, e encoder.Encoder, conn net.Conn, progressCh chan transfer.Progress) statemachine.StateFn {
	log.Println("Generating auth token")
	//on connection, generate random bytes and send to the client
	random := generateRandomBytes()
	outPkt := &message.Packet{Type: message.AUTH, Payload: random}
	_, err := shared.SendPacket(outPkt, conn, e)
	if err != nil {
		log.Println("Error sending AUTH token: " + err.Error())
		return nil
	}
	//use a closure to capture the value of the randomly generated bytes
	authenticateStateWrapper := func(pkt1 *message.Packet, e1 encoder.Encoder, conn1 net.Conn, pc1 chan transfer.Progress) statemachine.StateFn {
		return authenticateClientState(pkt1, e1, conn1, pc1, random)
	}
	return authenticateStateWrapper
}

func authenticateClientState(pkt *message.Packet, e encoder.Encoder, conn net.Conn, progressCh chan transfer.Progress, randomBytes []byte) statemachine.StateFn {
	log.Println("Authenticating client")
	if pkt.Type != message.AUTH {
		log.Println("Expecting AUTH, did not receive it")
		return nil
	}
	//get the bytes the client sent over
	b, ok := pkt.Payload.([]byte)
	if !ok {
		log.Println("Incorrect payload type")
		return nil
	}
	//XOR our generated bytes with the secret
	xORd := shared.XORSecret(randomBytes, shared.Secret)
	//and then MD5 hash to compare with client bytes
	hasher := md5.New()
	hashed := hasher.Sum(xORd)
	if len(hashed) != len(b) {
		log.Println("Authentication failed")
		return nil
	}
	//compare the client bytes to our bytes to
	//see if the client is authenticated
	for i := 0; i < len(hashed); i++ {
		if hashed[i] != b[i] {
			log.Println("Authentication failed")
			return nil
		}
	}
	log.Println("Authentication successful")
	outPkt := &message.Packet{Type: message.AUTH, Payload: []byte{000}}
	_, err := shared.SendPacket(outPkt, conn, e)
	if err != nil {
		log.Println("Error sending AUTH token: " + err.Error())
		return nil
	}
	return nil
}

func generateRandomBytes() []byte {
	size := 64
	rb := make([]byte, size)
	_, err := rand.Read(rb)
	if err != nil {
		log.Println(err)
	}

	return rb
}
